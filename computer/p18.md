## 18.1 优先队列的定义和简单实现

> 优先队列是一个以集合为基础的抽象数据类型, 优先队列中包含一些元素, 这些元素称为队列的结点, 优先队列的结点至少包含一种性质: 有序性. 即任意两个结点可以比较大小, 也就是说**优先队列中的每一个元素都有一个优先级**
> 
> ​ 普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （first in, largest out）的行为特征。通常采用堆数据结构来实现。

### 18.1.2 优先队列的简单实现

对于优先队列来说, 不同的元素可以有相同的优先级, 因此, 优先队列的插入运算即使在当前优先队列中存在与要插入元素 x 有相同的优先级元素时, 也要执行元素 x 的插入, 优先队列的实现方法有以下三种

#### 有序链表

> 用有序链表实现优先队列, 可在 O(1) 时间内实现 Min(H) 和 DeleteMin(H) 运算, 但 Insert(x, H) 在最坏情况下需要 O(n) 时间, 其中, n 为插入元素时优先队列中已有的元素个数

#### 二叉搜素树

> 用二叉搜索树表示有 n 个元素的优先队列, 则在最坏情况下 Insert(x, H) 和 DeleteMin(H) 运算需要 O(n) 时间, 在平均情况下需要 O(log<sub>2</sub>n) 时间

#### 无序链表

> 用无序链表实现优先队列, 则可在 O(1) 时间实现 Insert(x, H) 运算, 但 DeleteMin(H) 运算却需要 O(n) 时间

## 18.2 优先级树和堆

### 18.2.1 优先级树

#### 极小化优先级树 

在一棵优先级树的任意一条从根到叶的路径上，较高层结点有较小优先级。这类优先级树称为极小化优先级树。在极小化优先级树中执行 Insert(x，H)和 DeleteMin(H)运算所需的时间与树高有关，一般用平衡的优先级树来表示优先队列。

#### 极大化优先级树

在一棵优先级树中，任一结点中存储的元素的优先级不小于其孩子中存储的元素的优先级，这类优先级树称为极大化优先级树。

> 表示同一优先队列的优先级树不是唯一的, 另外, 优先级树可能退化成一个线性表

### 18.2.2 堆

!> 在下面的讨论中，如果不特别指明，所说的堆即指极小化堆，优先级树即指极小化优先级树。

当一棵优先级树是近似满二叉树时，称其为堆或偏序树。极小化优先级树相应的堆称为极小化堆；极大化优先级树相应的堆称为极大化堆

![image4fab8aa120a6e33b.png](https://img.waite.wang/images/2023/01/01/image4fab8aa120a6e33b.png)

> 通常情况下，堆即指极小化堆；优先级树即指极小化优先级树。

当堆中有 n 个元素时, 可以将这些元素存放在数组 A 的前 n 个单元, 用数组实现的极小化堆    Minheap 的结构如下

```c
typedef struct minheap * Heap;
// 极小化堆指针类型

typedef struct minheap {
    SetItem * data;
    // 堆中元素数组, 用于存储堆中元素
    int last;
    // 最后一个单元位置
    int maxsize;
    // 堆数组的最大长度
} MinHeap;
```

#### 堆的Delete(H)运算

1. 删去堆中最底层最右边的叶结点，该结点直接代替树根
2. 该结点不断与它具有较小优先级的儿子交换位置，直到它的两个儿子的优先级都不小宇宇它的优先级或它已降到叶结点的位置为止。一句话**优先级越大越往底层走**。

> 下图极小化堆执行Delete(H)运算

![image4fab8aa120a6e33b.png](https://img.waite.wang/images/2023/01/01/image4fab8aa120a6e33b.png)

第一步，删去堆中最底层最右边的叶结点，该结点直接代替树根

![watermarktype_ZmFuZ3poZW5naGVpdGkshadow_10text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MDU5NDU3size_16color_FFFFFFt_70.png](https://img.waite.wang/images/2023/01/01/watermarktype_ZmFuZ3poZW5naGVpdGkshadow_10text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MDU5NDU3size_16color_FFFFFFt_70.png)

第二步，50的优先级大于15，所以50与15交换顺序, 50的优先级大于20,50与20交换位置，50到叶结点位置，结束运算。

![image444fe1aa96d6d6da.png](https://img.waite.wang/images/2023/01/01/image444fe1aa96d6d6da.png)

#### 堆的Insert(x,H)运算

1. 将存放新元素的结点添加在堆的最底层。
2. 插入的元素的优先级小于其父结点中的元素的优先级，就交换他们的位置，直到新元素的优先级不小于其父结点中元素的优先级或已升到树根结点为止。一句话，**优先级越小越往树根走。**
3. Insert(x,H)运算在最坏情况下也只要O(logn)时间。

> 例如：在下图堆插入优先级为8的元素。

![image267e1c518a6fb82f.png](https://img.waite.wang/images/2023/01/01/image267e1c518a6fb82f.png)

（1）将插入元素添加到最底层

![image00f36e8b26e39cf2.png](https://img.waite.wang/images/2023/01/01/image00f36e8b26e39cf2.png)

（2）优先级越小越往树根走

![image54f4ae05b0527847.png](https://img.waite.wang/images/2023/01/01/image54f4ae05b0527847.png)

## 18.3 可并优先队列

可并优先队列也是一个以集合为基础的抽象数据类型。用堆来实现优先队列，可在O(log<sub>2</sub>n）时间内支持同一优先队列中的基本运算，但合并两个不同优先队列的效率不高。左偏树结构不但能在O(log<sub>2</sub>n）时间内支持同一优先队列中的基本运算，还能有效地支持两个不同优先队列的合并运算 

### 18.3.1 左偏树的定义

> 1. 左偏树是一类特殊的优先级树, 左偏树也有 极小化左偏树 和 极大化左偏树 之分
> 2. 极小化左偏树 优先级的根中存储的元素具有最小优先级, 从根到叶子的任一路径上, 各结点中元素按优先级的非递减序排列
> 3. 常用的左偏树分为左偏高树和左偏重树两种

对于二叉树中任意一个结点x，递归地定义其高度s(x)为

对于二叉树中任意一个结点x，递归地定义其重量w(x)为

![image4641a15ef4424973.png](https://img.waite.wang/images/2023/01/01/image4641a15ef4424973.png)

一棵优先级树是一棵左偏高树，当且仅当在该树的每个内结点处，其左儿子结点的高大于或等于其右儿子结点的高。

一棵优先级树是一棵左偏重树，当且仅当在该树的每个内结点处，其左儿子结点的重大于或等于其右儿子结点的重。

> 左偏高树性质：
> 
> 1. 以 x 为根的子树中至少有2<sup>s(x)</sup> - 1个结点:
> 2. 若以x为根的子树中有 m 个结点，则 s(x) 的值不超过 log<sub>2</sub>(m +1)
> 3. 从 x 出发的最右路经的长度恰为 s(x)。

<br/>

### 18.3.2 左偏树的合并运算

合并操作是左偏树最关键的运算, 它将录课分别以 x 和 y 为根的左偏树合并为一棵新的以 x 为根的左偏树

1. 在x、y中取较小的值最为合并后的根，假设x的值较小，则合并后x的根为新树的根，x的左子树为新树的左子树
2. 递归地合并x的右子树和y，若合并后不满足左偏性质（dist(lson)<dist[rson]）,则交换左右儿子，即swap(lson,rson)；
3. x 的右子树或 y 为空时，合并算法结束。

> 一棵 n 个结点的左偏树, 最右路径上最多有 log<sub>2</sub>(n + 1)个结点, 因此, 合并操作的时间复杂度为 O(log<sub>2</sub>(n))

![uTools_1672583214336.png](https://img.waite.wang/images/2023/01/01/uTools_1672583214336.png)

## 总结

1. 优先队列支持的主要集合运算是插入运算和删除最小元运算。
2. 优先级树和堆实现优先队列效率更高。
3. 可并优先队列也是以集合为基础的抽象数据类型，支持不同优先队列的合排运算。
4. 左偏树是实现可并优先队列的高级数据结构，可以在O(log<sub>2</sub>n)的时间内完成插入运算、删除最小元运算和不同优先队列的合并运算。

<br/>

## 题目

- 选择题
  1. 用有序表实现优先队列时，Insert(x，H)运算在最坏情况下的时间复杂度为
     1. O(log<sub>2</sub>n)
     2. O(n)
     3. O(nlog<sub>2</sub>n)
     4. O(n<sup>2</sup>)
  2. 常用的优先队列的实现方法不包括
     1. 有序链表
     2. 二叉搜索树
     3. 无序链表
     4. 散列表

<br/>

- 选择答案
  1. B 用有序链表实现优先队列,Insert(x,H)运算在最坏情况下需要 O(n)时间,Min(H)和DeleteMin(H)运算可在 O(1)时间内实现。
  2. D

<br/>

- 判断题
  1. 同一个优先队列的优先级树是唯一的。
  2. 利用左偏树结构合并两个不同优先队列的效率高于利用堆来合并的效率。
  3. 优先队列和可并优先队列都是以集合为基础的抽象数据类型。

<br/>

- 选择答案
  - 错(同一优先队列的优先级树不是唯一的,另外,优先级树还可能退化成一个线性表)
  - 对(堆来实现优先队列,可在 O(log<sub>2</sub>n)时间内支持同一优先队列中的基本运算,但合并两个不同优先队列的效率没有左偏树结构的效率高)
  - 对

<br/>

- 填空题
  1. 优先级树的根结点中存储的元素具有( )优先级
  2. 常用的左偏树分为左偏高树和( )

<br/>

- 填空题
  - 最小 左偏重树

<br/>

- 应用题
  - 请分别说明用有序链表和无序链表实现优先队列插入和删除算法时的时间复杂度。

<br/>

<br/>

有序链表

> 用有序链表实现优先队列, 可在 O(1) 时间内实现 Min(H) 和 DeleteMin(H) 运算, 但 Insert(x, H) 在最坏情况下需要 O(n) 时间, 其中, n 为插入元素时优先队列中已有的元素个数

 二叉搜素树

> 用二叉搜索树表示有 n 个元素的优先队列, 则在最坏情况下 Insert(x, H) 和 DeleteMin(H) 运算需要 O(n) 时间, 在平均情况下需要 O(log<sub>2</sub>n) 时间

 无序链表

> 用无序链表实现优先队列, 则可在 O(1) 时间实现 Insert(x, H) 运算, 但 DeleteMin(H) 运算却需要 O(n) 时间
