## 19.1 排序的基本概念

> 排序是按关键字的非递减或非递增顺序对一组记录重新进行排列的操作

### 19.1.2 相关概念

当排列记录中的关键字都不相同时, 则任何一个记录的无序序列经过排列后得到的结果唯一; 当待排序的序列中存在两个或两个以上关键字相等的记录时, 则经排序后得到的结果可能不唯一

#### 稳定排序和不稳定排序

> 稳定排序有：插入排序、冒泡排序、归并排序、基数排序
> 
> 不稳定排序有：选择排序、快速排序、希尔排序、堆排序

稳定排序：排序前后两个相等的数相对位置不变，则算法稳定
非稳定排序：排序前后两个相等的数相对位置发生了变化，则算法不稳定

> Tips: 对序列 (35, 28, 27, 62, 35', 81) 进行排序?

稳定排序: (18, 27, 35, 35', 62, 81)

不稳定排序: (18, 27, 35', 35, 62, 81)

#### 内部排序和外部排序

1. 内部排序是指待排序记录全部存放在计算机内存中进行排序的过程, 不需要访问外存, 适用于排序记录较少的情况
2. 外部排序是指待排序记录的数量很大, 内存无法容纳全部数据, 在排序的过程中需要借助外存的排序过程

#### 内部排序的方法

> 内部排序的过程是一个逐步扩大记录的有序序列长度的过程。

所有排序基本操作:

1. 比较两个记录关键字的大小
2. 根据比较结果, 将记录从一个位置移到另一个位置

内排序的方法有许多种，按所用策略不同，可归纳为五类：

1. 插入类: 将无序子序列中的一个或几个记录"插入"到有序序列中, 从而增加记录的有序子序列的长度, 主要包括: 直接插入排序, 折半插入排序, 希尔排序
2. 选择类: 从记录的无序子序列中"选择"关键字最大或最小的记录, 并将它加入到有序子序列中, 从而增加记录的有序子序列的长度, 主要包括: 简单选择排序, 树形选择排序, 堆排序
3. 交换类: 通过"交换"无序序列中的记录从而得到其中关键字最小或最大的记录, 并将它加入到有序子序列中, 从而增加记录的有序子序列的长度, 主要包括: 冒泡和快速排序
4. 归并类: 通过"归并"两个或两个以上的记录有序子序列, 逐步增加记录有序序列的长度, 主要包括: 2-路归并排序
5. 分配类: 唯一一类不需要进行关键字之间比较的排序方法, 排序时主要利用分配和收集两种基本操作来完成, 主要包括: 基数排序

#### 待排序记录的存储方式

1. 顺序表：记录之间的次序关系由其存储位置决定，实现排序需要移动记录。
2. 链表：记录之间的次序关系由指针指示，实现排序不需要移动记录，仅需修改指针即可。这种排序方式称为链表排序。
3. 待排序记录本身存储在一组地址连续的存储单元内，同时另设一个指示各个记录存储位置的地址向量，在排序过程中不移动记录本身，而移动地址向量中这些记录的“地址”，在排序结束之后再按照地址向中的值调整记录的存储位置。这种排序方式称为地址排序。

> 在本章中, 除了基数排序外, 待排序记录均顺序表存储      

```c
#define MAXSIXE 20

typedef int KeyType;
typedef char InfoType;
typedef struct
{
    KeyType key;
    InfoType otherinfo;
    // 其他数据项
} RedType;
typedef struct
{
    RedType r[MAXSIZE + 1];
    int length;
} SqList;
```

#### 排序算法效率的评价指标

1. **执行时间**: 排序算法的时间复杂度主要由**关键字的比较次数**和**记录移动次数**这两个指标决定
2. **辅助空间**: 排序算法的空间复杂度由排序算法所需的**辅助空间**决定. 辅助空间是除了存放待排序记录占用的空间之外, 执行算法所需要的其他存储空间, **理想的空间复杂度为O(1)**

## 19.2 插入排序

> 基本思想: 每一趟将二个待排序的记录，按其关键字的大小插人到已经排好序的一组记录的适当位置上，直到所有待排序记录全部插入为止

### 19.2.1 直接插入排序

> 直接插入排序是一种最简单的排序方法, 其基本操作是将一条记录插入到已排好序的有序表中, 从而得到一个新的, 记录数量加一的有序表

![image.png](https://img.waite.wang/images/2023/01/02/image.png)

```c
void InsertSort(SqList &L)
{
    int i, j;
    for (i = 2; i <= L.length; i++)
    {
        if (L.r[i].key < L.r[i - 1].key)
        {
            L.r[0] = L.r[i];
            // 将待插入的记录暂存到L.r[0]监视哨中
            L.r[i] = L.r[i - 1];
            // 记录后移
            for (j = i - 2; L.r[0].key < L.r[j].key; j--)
            // 向后查找插入位置
            {
                L.r[j + 1] = L.r[j];
            }
            L.r[j + 1] = L.r[0];
        }
    }
}
```

> 直接插入排序只需要一个记录的辅助空间r[0], 所有空间复杂度为 O(1)

#### 特点

- 稳定排序
- 算法简便, 且容易实现
- 也适用于链式存储结构, 只是在单链表上无需移动记录, 只需修改相应指针
- 更适合初始记录基本有序的情况, 当初始记录无序, n 较大时, 此算法的时间复杂度较高, 不宜采用

<br/>

### 19.2.2 希尔排序

> 1. 希尔排序采用分组插入的方法
> 2. 希尔对记录的分组, 不是简单地"逐段分割", 而是将相隔某个"增量"的记录分成一组

![image46625160e3a97944.png](https://img.waite.wang/images/2023/01/02/image46625160e3a97944.png)

```c
// 希尔排序
void ShellInsert(SqList &L, int dk) {
    for (int i = dk + 1; i <= L.length; i++) {
        if (L.r[i].key < L.r[i - dk].key) {
            L.r[0] = L.r[i];
            L.r[i] = L.r[i - dk];
            int j;
            for (j = i - 2 * dk; j > 0 && L.r[0].key < L.r[j].key; j -= dk) {
                L.r[j + dk] = L.r[j];
            }
            L.r[j + dk] = L.r[0];
        }
    }
}

void ShellSort(SqList &L, int dt[], int t) {
    for (int k = 0; k < t; k++) {
        ShellInsert(L, dt[k]);
        // 一趟增量为dt[k]的希尔插入排序
    }
}
```

> 改写

```c
#include<iostream>
using namespace std;
 
void print(int a[], int n)
{  
    for(int j= 0; j<n; j++)
	{  
           cout<<a[j] <<"  ";  
        }  
    cout<<endl;  
}
 
void shellSort(int a[], int n)  //a -- 待排序的数组, n -- 数组的长度
{
    int i,j,gap;   // gap为步长，每次减为原来的一半。
    for (gap = n / 2; gap > 0; gap /= 2)
    {
        // 共gap个组，对每一组都执行直接插入排序
        for (i = 0 ;i < gap; i++)
        {
            for (j = i + gap; j < n; j += gap) 
            { 
                // 如果a[j] < a[j-gap]，则寻找a[j]位置，并将后面数据的位置都后移。
                if (a[j] < a[j - gap])
                {
                    int tmp = a[j];
                    int k = j - gap;
                    while (k >= 0 && a[k] > tmp)
                    {
                        a[k + gap] = a[k];
                        k -= gap;
                    }
                    a[k + gap] = tmp;
                }
            }
        }
    }
}
 
int main()
{  
    int a[10] = {8,1,9,7,2,4,5,6,10,3};  
    cout<<"初始序列：";  
    print(a,10);  
    shellSort(a,10);  
    cout<<"排序结果：";  
    print(a,10);  
} 
```

#### 特点

1. 记录跳跃式地移动导致排序方法不稳定
2. 只能用于顺序结构, 不能用于链式结构
3. 增量序列可以有各种取法, 但应该使增量序列中的值没有除 1 之外的公因子, 并且最后一个增量值必须为 1
4. 记录总的比较次数和移动次数都比直接插入排序要少, n 越大效果越明显, 所以适合初始记录无序, n 较大的情况

## 19.3 交换排序

> 两两比较待排序的关键字, 一旦发现两个记录不满足次序要求时则进行交换, 直到整个序列全部满足要求为止

### 19.3.1 冒泡排序

![20201013153248880.gif](https://img.waite.wang/images/2023/01/02/20201013153248880.gif)

```c
void BubbleSort(SqList &L) {
    int m = L.length -1;
    int flag = 1;
    while (int i = 1; i <= m && flag == 1; i++) {
        flag = 0;
        for (int j = m; j >= i; j--) {
            if (L.r[j].key < L.r[j-1].key) {
                L.r[0] = L.r[j];
                L.r[j] = L.r[j-1];
                L.r[j-1] = L.r[0];
                flag = 1;
            }
        }
    }
}
```

> 复写

```c
#include <iostream>

using namespace std;

// 主函数
int main(int argc, char *argv[])
{
    int arr[] = {1, 3, 5, 7, 9, 2, 4, 6, 8}; // 待排序数组
    int cnt = sizeof(arr) / sizeof(int);     // 数组长度

    // 冒泡排序
    for (int i = 0; i < cnt; ++i)
    {
        for (int j = 0; j < cnt - 1 - i; ++j)
        {
            if (arr[j] > arr[j + 1]) // 从小排到大
            {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }

    // 打印数组
    for (int i = 0; i < cnt; ++i)
    {
        cout << arr[i] << " ";
    }

    cout << endl;

    return 0;
}
```

#### 特点

1. 稳定排序
2. 可用于链式存储结构
3. 移动记录次数较多, 算法平均时间性能比直接插入排序插, 当初始记录无序, n 较大时, 不宜采用

### 19.3.2 快速排序

快速排序是由冒泡排序改进而来的。在冒泡排序过程中，只对相邻的两个记录进行比较，因此每次交换两个相邻记录时只能消除一个逆序。如果能通过两个(不相邻)记录的一次交换，消除多个逆序，则会大大加快排序的速度。**快速排序方法中的一次交换可能消除多个逆序。**

1. 升序：假设有一个数组array[10]，其中的元素为{ 5, 3, 9, 16, 28, 0, 4, 7, 29, 44 }。
2. 首先我们需要选择一个元素作为分界值key，例如选首元素5；然后我们可以用两个变量i=0，j=9去记录数组的首尾下标。
3. 从array[j]开始和key比较，如果比key大，则j自减，直到找到比key小的数（array[6]），此时判断i是否小于j（不是直接跳出循环到步骤5），如果是则将array[j]赋值给array[i]（数组变成了{ 4, 3, 9, 16, 28, 0, 4, 7, 29, 44 }），然后i自增（自增只是为了少比较一次）。
4. 然后我们从array[i]开始和key比较，比key小，i自增，直到找到比key大的数（array[2]），此时判断i是否小于j（不是直接跳出循环到步骤5），如果是则将array[i]给array[j]（数组变成了{ 4, 3, 9, 16, 28, 0, 9, 7, 29, 44 }），然后j自减（自减只是为了少比较一次）。
5. 重复以上步骤直到i==j时结束（数组变成了{ 4, 3, 0, 16, 28, 16, 9, 7, 29, 44 }，此时i和j都是3）；
6. 循环结束后把key值赋给array[i]（数组变成了{ 4, 3, 0, 5, 28, 16, 9, 7, 29, 44 }）；做到这里我们是不是可以发现，分界值key左边的数都比他小，而分界值key右边的数都比他大，这样我们的第一轮快排就完成了。
7. 此时的5把数组分成了两个未排序数组，我们对两边继续重复上述步骤即可（递归思想）。

![1d43762b58681c0ace7caa3fa93b33da.gif](https://img.waite.wang/images/2023/01/02/1d43762b58681c0ace7caa3fa93b33da.gif)

```c
int Parttion(SqList &L, int low, int high)
// 对顺序表L中的子序列L.r[low..high]作一趟快速排序，返回枢轴记录的位置
{
    L.r[0] = L.r[low];
    int pivotkey = L.r[low].key;
    while (low < high)
    {
        while (low < high && L.r[high].key >= pivotkey)
            --high;
        L.r[low] = L.r[high];
        // 比枢轴记录小的移到低端
        while (low < high && L.r[low].key <= pivotkey)
            ++low;
        L.r[high] = L.r[low];
        // 比枢轴记录大的移到高端
    }
    L.r[low] = L.r[0];
    // 枢轴记录到位
    return low;
}

void QSort(SqList &L, int low, int high)
// 对顺序表L中的子序列L.r[low..high]作快速排序
{
    if (low < high)
    {
        int pivotloc = Parttion(L, low, high);
        QSort(L, low, pivotloc - 1);
        QSort(L, pivotloc + 1, high);
    }
}

void QuickSort(SqList &L)
// 对顺序表L作快速排序
{
    QSort(L, 1, L.length);
}
```

> 复写

```c
#include <iostream>
using namespace std;

void QuickSort(int *arr, int start, int end)
{
    if (start >= end)
        return;
    int i = start;
    int key = arr[i];
    int j = end;
    while (i < j)
    {
        while (i < j && key <= arr[j])
        {
            j--;
        }
        if (i < j)
            arr[i++] = arr[j];
        while (i < j && key >= arr[i])
        {
            i++;
        }
        if (i < j)
            arr[j--] = arr[i];
    }
    arr[i] = key;
    QuickSort(arr, start, i - 1);
    QuickSort(arr, i + 1, end);
}
int main()
{
    int array[10] = {5, 3, 9, 16, 28, 0, 4, 7, 29, 44};
    QuickSort(array, 0, 9);
    for (int i = 0; i < 9; i++)
    {
        cout << array[i] << endl;
    }
    return 0;
}
```

#### 特点

1. 由于记录的移动是非顺次的, 所以快速排序是一种不稳定的排序方法
2. 由于在排序过程中需要定位表的上下界, 所以适用于顺序结构, 很难用于链式结构
3. 适用于初始记录无序, 记录较多的情况, 在记录较多时, 在平均情况下快速排序是所有内部排序方法中速度最快的一种

## 19.4 选择排序

> 每一趟从待排序的记录中选出关键字最小的记录, 按顺序放在已排序的记录序列的最后, 直到全部排完为止

### 19.4.1 简单选择排序

简单选择排序是一种简单的选择排序方法, 也称作直接选择排序

![d350fd68e1124bbabeeb57ba32f266b4.gif](https://img.waite.wang/images/2023/01/02/d350fd68e1124bbabeeb57ba32f266b4.gif)

```c
void SelectSort(SqList &L)
{
    int i, j, k;
    for (i = 1; i < L.length; i++)
    {
        k = i;
        for (j = i + 1; j <= L.length; j++)
        {
            if (L.r[j].key < L.r[k].key)
            {
                k = j;
            }
        }
        if (k != i)
        {
            L.r[0] = L.r[i];
            L.r[i] = L.r[k];
            L.r[k] = L.r[0];
        }
    }
}
```

#### 特点

1. 稳定排序
2. 可用于链式存储结构
3. 移动记录较少, 当每一记录占用的空间较多时, 此方法比直接插入排序快

### 19.4.2 堆排序

堆是一种叫做完全二叉树的数据结构，可以分为大根堆，小根堆，而堆排序就是基于这种结构而产生的一种程序算法。

1. 大根堆:每个节点的值都大于或者等于他的左右孩子节点的值
2. 小根堆:每个结点的值都小于或等于其左孩子和右孩子结点的值

![image.png](https://img.waite.wang/images/2023/01/03/image.png)

> 排序思想
> 
> 1. 首先将待排序的数组构造成一个大根堆，此时，整个数组的最大值就是堆结构的顶端
> 2. 将顶端的数与末尾的数交换，此时，末尾的数为最大值，剩余待排序数组个数为n-1
> 3. 将剩余的n-1个数再构造成大根堆，再将顶端数与n-1位置的数交换，如此反复执行，便能得到有序数组
> 
> 注意:升序用大根堆，降序就用小根堆(默认为升序)

Tips: 如何构建初始堆。设有一个无序序列 { 1, 3, 4, 5, 2, 6, 9, 7, 8, 0 }。

![image69d533f0c9058a08.png](https://img.waite.wang/images/2023/01/03/image69d533f0c9058a08.png)

![image6263a4983056e497.png](https://img.waite.wang/images/2023/01/03/image6263a4983056e497.png)

#### 特点

1. 不稳定排序
2. 只能用于顺序结构, 不能用于链式结构
3. 初始建堆所需的比较次数较多, 因此记录数较少时不宜采用, 堆排序在最坏的情况下时间复杂度为 O(log<sub>2</sub>n), 相对于快速排序最坏情况下的 O(n<sup>2</sup>) 而言是一个优点, 当记录较多时较为高效, 空间复杂度为 O(1)

## 19.5 归并排序

> 归并排序就是将两个或两个以上的有序表合并成一个有序表的过程, 将两个有序表合并成一个有序表的过程叫做 **2-路归并**, 2-路归并最为 简单常用

1. 定义一个新数组c，可以容纳a和b两个数组中的所有元素；
2. 初始化三个下标（都指向第一个元素），i给a数组，j给b数组，k是新数组c的；
3. a[i]和b[j]进行比较：若a[i]<b[j]，将a[i]填入c[k]，i++，k++；若a[i]>b[j]，将b[j]填入c[k]，j++，k++;
4. 循环第三步，直至其中一个数组中的数据全部填入数组c中，再将另外一个还有剩余的数组中的元素放入新数组c中。

![watermarktype_ZHJvaWRzYW5zZmFsbGJhY2sshadow_50text_Q1NETiBATi1Xsize_20color_FFFFFFt_70g_sex_16.png](https://img.waite.wang/images/2023/01/03/watermarktype_ZHJvaWRzYW5zZmFsbGJhY2sshadow_50text_Q1NETiBATi1Xsize_20color_FFFFFFt_70g_sex_16.png)

```c
#include <stdio.h>

#define MAXSIE 20

typedef int KeyType;
typedef char InfoType;
typedef struct
{
    KeyType key;
    InfoType otherinfo;
    // 其他数据项
} RedType;
typedef struct
{
    RedType r[MAXSIZE + 1];
    int length;
} SqList;

// 相邻两个有序子序列的归并
void Merge(RedType R[], RedType T[], int low, int mid, int high)
{
    int i = low, j = mid + 1, k = low;
    while (i <= mid && j <= high)
    // 将 R 中记录由小到大并入 T 中
    {
        if (R[i].key <= R[j].key)
            T[k++] = R[i++];
        else
            T[k++] = R[j++];
    }
    while (i <= mid)
        T[k++] = R[i++];
        // 将剩余的 R[i..mid] 复制到 T
    while (j <= high)
        T[k++] = R[j++];
        // 将剩余的 R[j..high] 复制到 T
}

// 归并排序
void MSort(RedType R[], RedType T[], int low, int high)
{
    int mid;
    RedType TR[MAXSIZE + 1];
    if (low == high)
        T[low] = R[low];
    else
    {
        mid = (low + high) / 2;
        // 将当前无序区 R[low..high] 平分为 R[low..mid] 和 R[mid+1..high]
        MSort(R, TR, low, mid);
        // 递归将 R[low..mid] 归并为有序的 TR[low..mid]
        MSort(R, TR, mid + 1, high);
        // 递归将 R[mid+1..high] 归并为有序的 TR[mid+1..high]
        Merge(TR, T, low, mid, high);
        // 将 TR[low..mid] 和 TR[mid+1..high] 归并到 T[low..high]
    }
}
void MergeSort(SqList &L)
{
    MSort(L.r, L.r, 1, L.length);
}
```

### 特点

1. 稳定排序
2. 可用于链式结构, 且不需要附加存储空间, 但递归实现时仍需要开辟相应的递归工作栈

<br/>

## 总结

![imagee5fef23d13e029f2.png](https://img.waite.wang/images/2023/01/03/imagee5fef23d13e029f2.png)

从上表的时间复杂度的平均情况来看，直接插入排序、冒泡排序和简单选择排序的速度较慢，而其他排序方法的速度较快。从算法实现的角度来看，速度较慢的算法实现过程比较简单，称之为简单的排序方法；而速度较快的算法可以看作是对某一排序算法的改进，称之为先进的排序方法，但这些算法实现过程比较复杂。总的来看，各种排序算法各有优缺点，没有哪一种是绝对最优的。在使用时需根据不同情况适当选用，甚至可将多种方法结合起来使用。一般综合考虑以下因素：

1. 待排序的记录个数；
2. 记录本身的大小；
3. 关键字的结构及初始状态；
4. 对排序稳定性的要求；
5. 存储结构。

根据这些因素和上表所做的比较，可以得出以下几点结论：

1. 当待排序的记录个数 n 较小时，n<sup>2</sup>和 nlog<sub>2</sub>n 的差别不大，可选用简单的排序方法。而当关键字基本有序时，可选用直接插入排序或冒泡排序，排序速度很快，其中直接插入排序最为简单常用、性能最佳。
2. 当 n 较大时，应该选用先进的排序方法。对于先进的排序方法，从平均时间性能而言，快速排序最佳，是目前基于比较的排序方法中最好的方法。但在最坏情况下，即当关键字基本有序时，快速排序的递归深度为 n, 时间复杂度为 O(n<sup>2</sup>)，空间复杂度为O(n)。堆排序和归并排序不会出现快速排序的最坏情况，但归并排序的辅助空间较大。这样，当 n 较大时，具体选用的原则是：
   1. 当关键字分布随机，稳定性不做要求时，可采用快速排序；
   2. 当关键字基本有序，稳定性不做要求时，可采用堆排序；
   3. 当关键字基本有序，内存允许且要求排序稳定时，可采用归并排序

<br/>

## 题目

- 选择题
  1. 下列排序方法中，不稳定的排序方法是
     1. 直接插入排序
     2. 简单选择排序
     3. 冒泡排序
     4. 希尔排序
  2. 冒泡排序是一种( )排序。
     1. 插入
     2. 交换
     3. 归并
     4. 选择
  3. 堆的形状是
     1. 二叉排序树
     2. 平衡二叉树
     3. 完全二叉树
     4. 满二叉树
  4. 从未排序序列中挑选元素，将其放在已排序序列的一端，这种排序方法称为
     1. 选择排序
     2. 插入排序
     3. 快速排序
     4. 冒泡排序
  5. 快速排序在( )情况下最易发挥其长处。
     1. 被排序的数据较少
     2. 被排序的数据已基本有序
     3. 被排序的数据完全无序
     4. 被排序的数据中最大值和最小值相差悬殊

<br/>

- 选择答案

![image65eb1ab96badad14.png](https://img.waite.wang/images/2023/01/03/image65eb1ab96badad14.png)

<br/>

- 判断题
  1. 快速排序属于插入类排序。
  2. 评价排序算法好坏的标准主要有执行时间和辅助空间。
  3. 简单选择排序需经过n-1趟才能完成排序。

<br/>

- 选择答案

![image24a38019c80602e0.png](https://img.waite.wang/images/2023/01/03/image24a38019c80602e0.png)

<br/>

- 填空题
  1. 在堆排序、快速排序、直接插入排序中，稳定的排序方法是( )
  2. 快排序在最坏情况下的时间复杂度是 ( )
  3. 若用冒泡排序对关键字{8，5，13，10，24，12）进行从小到大的排序，第1趟排序后的结果 ( )

<br/>

- 填空答案
  - 直接插入排序
  - O(n<sup>2</sup>)
  - 5, 8, 10, 13, 12, 24

<br/>

- 应用题
  - 写出对关键字序列{40, 24, 80, 18, 20）进行冒泡排序的每一趟结果。
  - 对关键字序列{12, 5, 10, 21, 18）使用直接插入排序方法由小到大进行排序、请写出每一趟排序的结果

<br/>

- 应用答案
  - 1. 24, 40, 18, 20, (80)
    2. 24, 18, 20, (40, 80)
    3. 18, 20, (24, 40, 80)
    4. 18, (20, 24, 40, 80)
  - 1. 初始(12), 5, 10, 21, 18
    2. (5, 12), 10, 21, 18
    3. (5, 10, 12), 21, 18
    4. (5, 10, 12, 21), 18
    5. (5, 10, 12, 18, 21)