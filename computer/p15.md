## 15.1 评价算法优劣的基本标准

1. 正确性: 算法的正确性是评价一个算法优劣的最重要的标准。
2. 可读性: 算法的可读性是指一个算法可供人们阅读的容易程度。
3. 健壮性: 健壮性是指一个算法对不合理数据输入的反应能力和处理能力，也称为容错性。
4. 高效性: 高效性包括空间和时间两个方面, 时间高效是指算法设计合理, 执行效率高, 可以用时间复杂度来度量, 空间高效是指算法占用存储容量合理, 可以用空间复杂度来度量,   时间复杂度 和 空间复杂度 是衡量算法的两个指标

<br/>

## 15.2 算法的时间复杂度

1. 算法效率分析的目的是看算法是否可行, 并在同一问题存在多个算法时, 可进行时间和空间性能上的比较, 以便从中挑选出较优算法
2. 衡量算法效率的方法主要有两类: 事后统计法和事前分析估算法(常用)

### 15.2.1 问题规模和语句频度

> 不考虑计算机的软硬件等环境因素, 影响算法时间代价的最主要因素是问题规模
> 
> 问题规模是指算法求解问题输入量的多少，是问题大小的本质。而一条语句的重复执行次数称为语句频度。(一个算法的执行时间大致等于其所有语句执行的时间。)
> 
> 设每条语句执行一次所需时间均是单位时间, 则一个算法执行时间可用该算法中所有语句频度来度量

### 15.2.2 算法的时间复杂度定义

> 在计算机科学中，时间复杂性，又称时间复杂度，算法的时间复杂度是一个函数，它定性描述该算法的运行时间。这是一个代表算法输入值的字符串的长度的函数。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，亦即考察输入值大小趋近无穷时的情况
> 
> 算法的时间复杂度不仅依赖于问题的规模 ,也取决于待输入数据的性质(如输人数据元素的初始状态)。

在T(n)中，n 叫做问题的规模，当 n 不断变化时，语句频度 T(n) 也会变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。

![image.png](https://img.waite.wang/images/2022/12/29/image.png)

- 满足如上公式时，即当n -> 正无穷时，二者之比为非0常数时，我们称作 f(n) 是 T(n) 同数量级函数。
- 此时就计作 T(n)=O(f(n))，大O表示”同阶“，同等数量级。
- 这个O(f(n)) 即为算法的 渐进时间复杂度，简称 时间复杂度。

### 15.2.3 算法的时间复杂度举例

#### 常量阶

```c
for(i = 0;i < 1000;i ++)
{
    x ++;
    s = 0;
}
```

>  由于算法的执行时间是一个与问题规模n无关的常数,所以算法的时间复杂度为T(n)=O(1).

#### 线性阶

```c
for(i = 0;i < n;i ++)
{
    x ++;
}
```

> 由于x自增的频率为f(n)=n,所以算法的时间复杂度为T(n)=O(n),称为线性阶。

#### 平方阶

```c
for(i = 0;i < n;i++)
    for(j = 0; j < n; j++)
        x ++;
```

> 由于x自增频率为f(n)=n<sup>2</sup>,所以算法的时间复杂度为T(n)=O(n<sup>2</sup>),称为平方阶。

#### 立方阶

```c
for(i = 0; i < n; i++)
    for(j = 0; j < n; j++)
        for(k = 0; k < n; k++)
            x ++;
```

> 由于x自增频率为f(n)=n<sup>3</sup>,所以算法的时间复杂度为T(n)=O(n<sup>3</sup>),称为立方阶。

#### 对数阶

```c
for(i = 0; i < n; i = i * 2)
{
    x ++;
}
```

> 由于x自增的频率为2f(n)=n,即f(n)=log<sub>2</sub>n,所以算法的时间复杂度为T(n)=O(log<sub>2</sub>n),称为对数阶。

### 15.2.4 最好, 最坏和平均时间复杂度

> 算法在最好情况下的时间复杂度为最好时间复杂度（指算法计算量可能达到的最小值）；在最坏情况下的时间复杂度为最坏时间复杂度（指算法计算量可能达到的最大值）；算法的平均时间复杂度是指算法在所有可能情况下，按照输入实例等概率出现时，算法计算量的加权平均值。通常只讨论最坏情况下的算法复杂度。

## 15.3 算法的空间复杂度

> 1. 空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))。比如直接插入排序的时间复杂度是O(n^2),空间复杂度是O(1) 。而一般的递归算法就要有O(n)的空间复杂度了，因为每次递归都要存储返回信息。一个算法的优劣主要从算法的执行时间和所需要占用的存储空间两个方面衡量
> 2. 若输入数据所占空间只取决于问题本身，和算法无关，则只需要分析除输入和程序之外的额外空间。

### 15.3.1 空间复杂度举例

#### 常数阶

```c
for(i = 0; i < n / 2; i++)
{
    t = a[i];
    a[i] = a[n-i-1];
    a[n-i-1] = t;
}
```

> 该算法只需要额外借用一个变量t，故算法空间复杂度为O(1)。

#### 线性阶

```c
for(i = 0; i < n; i++)
{
    b[i] = a[n-i-1];
}

for(i = 0; i < n; i++)
{
    a[i] = b[i];
}
```

> 该算法需要额外借用一个大小为n的辅助数组，故算法空间复杂度为O(n)。

## 总结

算法分析的两个主要方面是分析算法的时间复杂度和空间复杂度，以考察算法的时间和空间效率。一般情况下，鉴于运算空间较为充足，故将算法的时间复杂度作为分析的重点。算法执行时间的数量级称为算法的渐近时间复杂度，T(n)=O(f(n))，它表示随着问题规模”的增大，算法执行时间的增长率和f(n)的增长率相同，简称时间复杂度。

<br/>

## 题目

- 选择题
  1. 算法的复杂度取决于
     1. 问题的规模
     2. 待处理数据的初态
     3. 计算机的配置
     4. A 和 B
  2. 算法分析的两个主要方面是
     1. 空间复杂度和时间复杂度
     2. 正确性和简单性
     3. 可读性和文档性
     4. 数据复杂性和程序复杂性
  3. 下列程序的时间复杂度为
     ```c
     count = 0;
     for(k = 1; k <= n; k *= 2)
       for(j = 1; j <= n; j++)
         count ++;
     ```
     1. O(log<sub>2</sub>n)
     2. O(n)
     3. O(nlog<sub>2</sub>n)
     4. O(n<sup>2</sup>)

<br/>

<br/>

- 选择答案

![imageb18bfe5d3b576780.png](https://img.waite.wang/images/2022/12/29/imageb18bfe5d3b576780.png)

!> 只考虑 n, 不考虑其他干扰元素